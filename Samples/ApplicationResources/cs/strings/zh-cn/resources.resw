<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="InputTextBlock1.Text" xml:space="preserve">
    <value>有可能当应用程序正在运行时，系统语言、显示尺寸、对比度灯设置发生了变化，为了处理这些事件，应该为这些事件注册相应的监听器做相应的变化。</value>
    <comment>It is possible that, while an application is running, the language, scale, contrast or other settings may change. In order to handle these events, event listeners should be registered to listen for and react to the change.</comment>
  </data>
  <data name="InputTextBlock2.Text" xml:space="preserve">
    <value>注意：如果有准备了不同缩放尺寸下显示的图片，需要在XMAL中显示，当缩放发生变化时没有必要使用一个监听器重新加载图片。当需要时XMAL运行时系统会自动加载图片。当运行在一个多显示器系统时，当把应用程序从一个底DPI显示拖动到高DPI显示器或其他中可以看到。</value>
    <comment>Note: If an image with variants for different scales is used, as shown in the File Resources in XAML scenario, it is not necessary to use an event listener to reload images when scale has changed. The XAML runtime will automatically reload images as needed. This can be seen in the File Resources in XAML scenario when running on a multi-monitor system configured with a low-DPI monitor and a high-DPI monitor by dragging the app from one monitor to the other.</comment>
  </data>
  <data name="InputTextBlock3.Text" xml:space="preserve">
    <value>注意：应用程序语言演示程序使用PrimaryLanguageOverride属性来覆盖应用程序的语言。 在这种情况下如果设置了特定的语言，这种情况下在设置中更改语言不会有任何明显的效果。 通过这个场景可以看到效果，在应用程序语言场景中确保"优先使用语言 (推荐)"选项被选择。</value>
    <comment>Note: the Application Languages scenario demonstrates use of the PrimaryLanguageOverride property to override the language used for the app. If a specific language was set in that scenario, then changing the language in Settings will not have any visible effect in this scenario. To see an effect in this scenario, make sure that the "Use language preferences (recommended)" option is selected in the Application Languages scenario.</comment>
  </data>
  <data name="InputTextBlock4.Text" xml:space="preserve">
    <value>点击下面的按钮来显示当前资源的内容（对应语言所显示的内容），然后今日电脑系统设置 &gt; 时间和语言 &gt; 区域和语言，并添加一个应用程序支持的语言（如：简体中文）。然后把添加的语言移动到最上面（作为首选语言）。</value>
    <comment>Click the button below to show resources for the current context. Next, change the language by going to PC Settings &amp;gt; Time &amp;amp; language &amp;gt; Region &amp;amp; language and add a language that is supported by the app (e.g., Japanese); then move the new language to the top of the list (Set as primary).</comment>
  </data>
  <data name="string1" xml:space="preserve">
    <value>欢迎来到Windows 10 - UWP</value>
  </data>
</root>